传输安全
* 浏览器到达服务器，中间可能会经过很多代理服务器和链路设备，传输链路窃听篡改
* 如何知道到达服务器经过哪些节点呢，linux中可以通过traceroute命令
* 窃听危害：非法获取敏感信息
* 篡改危害：插入广告，重定向网站，无法防御XSS和CSRF工具
* 实例：运营商劫持、局域网劫持，公共wifi获取密码

> 测试代理工具：anyproxy
* 开启一个管理界面（8002） + 代理服务（8001）
* chrome插件（SwitchyOmega），设置代理（8001）

HTTPS原理
* HTTP之所以容易篡改和窃听，主要原因就是HTTP是明文传输
* HTTPS采用加密传输，但会有"中间人攻击"，解决这个问题，需要引入信任机制-证书机制

如何确定服务器身份
IMG

任何一个环节出现问题都会导致不安全，必须保证
* 证书无法伪造
* 证书私钥不被泄露
* 域名管理权不泄露
* CA坚守原则

CA是如何验证的呢，两种方式
1. 验证网站内容，CA访问网站指定的地址，要求你返回指定的内容，可以证明你对网站有所有权
2. 设置DNS记录，访问指定网址能得到指定值，证明你有域名管理权

密码的作用：证明你是你

密码的存储
* 密码泄露可能性
  * 数据库被偷
  * 服务器被入侵
  * 通讯被窃听
  * 内部人员泄露
  * 其他网站（撞库）
* 如何安全存储
  * 严禁明文存储（防泄漏）
  * 单向变换（防泄漏）
  * 变化（算法）复杂度要求（防猜解）
  * 密码（本身）复杂度要求（防猜解）
  * 加盐（防猜解）
* 哈希算法（正式名：信息摘要算法）
  * 明文-密文一一对应
  * 雪崩效应
  * 密文-明文 无法反推
  * 密文固定长度
  * 常见哈希算法：md5 sha1 sha256
* 彩虹表
  * 算法组合大大增加复杂度
  * 通过加固定字符串加长长度 + 加盐（为每个用户生成不同的字符串）

密码的传输安全
* https传输
* 频率限制（密码猜解）
* 前端加密意义有限（只能防止原始密码泄露，发生不同网站之间撞库，但并不能阻止用户登录和获取信息）
  * 前端通过JS加密密码（可以考虑加用户名+固定字符串（SUGAR）增大复杂度）
  * 此时后端加密是对前端加密结果的再次加密

密码替代方案
* 对用户而言，密码记忆太复杂了
* 生物特征密码
  * 指纹
  * 声纹
  * 虹膜
  * 人脸
* 生物特征问题
  * 私密性 - 容易泄露
  * 安全性 - 碰撞（相似性，概率性，无法hash）
  * 唯一性 - 终身唯一 无法修改

关系型数据库
* 存放结构化数据
* 可高效操作大量数据
* 方便处理数据之间的关联往西

SQL注入：和XSS类似，一部分数据变成了程序的一部分

神奇的SQL
```shell
select * from table where id = "10" and 1 = 0
select * from table where id = "10" or 1 = 1
select * from table where id = "10" and mid(version(),1,1)=5
select * from table union select 1,2,3 from table2
...
```

SQL注入危害
* 猜解密码
* 获取数据
* 删库删表
* 拖库

SQL注入防御
* 关闭错误输出（增加注入难度）
* 检查数据类型（是否符合要求）
* 对数据进行转义（可能变成程序的部分转义）
* 使用参数化查询
  * 第一次表明语句（意图：Prepare Statement）
  * 第二次指名参数（执行语句）
* 使用ORM（对象关系映射），例如node中有sequelize

NoSQL注入和防御
* 检查数据类型，类型转换
* 写完整条件（等于多少）

上传问题防御
* 上传问题
  1. 文件由用户上传
  2. 通过url访问刚上传的文件
  3. 文件有可能被当做程序解析
* 限制上传后缀
* 文件类型检查（MIME，这是浏览器给的，不用浏览器作为客户端就可以绕过）
* 文件内容检查（文件会有一个固定的开头）
* 程序输出：不让用户可以直接访问，而是通过程序的方式读一遍再给用户
* 权限控制 - 可写可执行互斥原则，使用低权限用户部署服务

信息泄露
* 泄露系统敏感信息（服务器配置、密码等）
* 泄露用户敏感信息（泄露用户密码）

信息泄露途径
* 错误信息失控
* SQL注入
* 水平权限控制不当
* XSS/CSRF
* ...

社会工程学诈骗
* 昵称、真名、手机号、身份证号、邮箱、密码
* 你的身份由你掌握的资料确定

OAuth流程
1. 用户请求第三方登录
2. 重定向到QQ
3. 用户输入密码登录
4. 登录成功 跳回网站
5. 网站向QQ获取accessToken
6. QQ给网站返回accessToken
7. 登录完成

OAuth思想
* 一切行为由用户授权
* 授权行为不泄露敏感信息
* 授权会过期

利用OAuth防止资料外泄（网站拆分：敏感资料 + 业务）
1. 用户登录（敏感资料）
2. 派发票据
3. 带票据请求业务
4. 业务带票据请求敏感资料
5. 敏感资料返回票据对应的数据
6. 返回数据

特点
* 用户授权读取资料
* 无授权资料不可读取
* 不允许批量获取数据
* 数据接口可风控审计

DOS攻击
* 拒绝服务（deny of service）
* 模拟正常用户，但是量十分庞大，大量占用服务器资源，导致无法服务正常用户
* 类型
  * TCP半连接
  * HTTP链接
  * DNS服务器（一般访问负载较小）
* DDOS攻击（大规模分布式拒绝服务攻击）
  * 流量可达几十到上百G
  * 分布式（肉鸡、代理）
* 极难防御，有限防御帮啊
  * 防火墙
  * 交换机、路由器
  * 流量清洗
  * 高防IP
* 攻击预防
  * 避免重逻辑业务（如果无可避免，可以采用任务的方式）
  * 快速失败快速返回
  * 防雪崩机制（清楚自己的负载，通过拒绝服务防止超过瓶颈）
  * 有损服务（某个服务挂掉，不影响其他服务）
  * CDN（减轻服务器压力）

重放攻击
* 请求被窃听或记录，再次发起相同的请求，产生意外的结果
  * 用户被多次消费
  * 用户登录态被盗取
  * 多次抽奖
* 防御
  * 加密（HTTPS）
  * 再次发送失效
    * 时间戳
    * token
    * nonce（number once）
    * 签名

总结
* XSS原理：用户数据被当成脚本在页面执行
* XSS防御
  * 不要变成程序（转义，白名单）
  * 即使变成程序也无法执行（浏览器内置检测，CSP）
* CSRF原理：浏览器访问服务器时会带上cookie，第三方应用通过表单和图片等方式访问我们服务器时，同样会带上cookie，导致用户在不知情的情况下发起请求，而这个请求是带有用户身份的
* CSRF危害：盗用用户身份，你说能干啥
* CSRF防御
  * 不允许第三方应用带上cookie，通过same-site属性，但目前只有chrome支持
  * 增加用户感知，验证码
  * token
  * 判断referer
* cookies作用
  * 功能层面：浏览器端存储数据
  * 应用层面：网站配置，用户登录态等
* cookies和localstorage区别
  * 兼容性，localstorage是html5新增的，低版本浏览器支持
  * cookies会自动跟随请求发送
  * cookies可以设置过期时间，从而自动删除
  * 容量
* cookies和session的关系：session是基于cookie的存储而实现的
* cookies有哪些特性
  * 域名，不能跨域
  * path
  * 有效期
  * httpOnly
  * secure
  * sameSite
* 如何删除一个cookie值：设置过期时间为一个过去的时间
  